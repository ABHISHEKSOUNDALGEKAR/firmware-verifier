<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Spec-Driven Firmware Verifier (Pyodide, no server)</title>
  <style>
    :root { --bg:#0b1020;--card:#121833;--muted:#8ea0ff;--text:#eef2ff;--good:#7cf37c;--bad:#ff7d7d; }
    body { margin:0; background:var(--bg); color:var(--text); font:16px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial }
    .wrap { max-width:1100px; margin:32px auto; padding:0 16px }
    .hero { display:flex; gap:16px; align-items:center; justify-content:space-between; flex-wrap:wrap }
    h1 { font-size:28px; margin:0 0 6px } .sub{color:var(--muted)}
    .card { background:var(--card); border:1px solid #273069; border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.25) }
    textarea, pre { font-family:ui-monospace,monospace; width:100%; background:#0a0f21; color:var(--text);
                    border:1px solid #2a335e; border-radius:12px; padding:12px }
    textarea { min-height:220px; resize:vertical }
    .row { display:grid; grid-template-columns:1fr 1fr; gap:16px }
    .controls { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px }
    button { background:#1f2a60; color:var(--text); border:1px solid #3a4aa3; border-radius:12px; padding:10px 14px; cursor:pointer; font:inherit }
    button.primary { background:#2443a3; border-color:#5470ff }
    button.good { background:#114e2d; border-color:#24d268 }
    select { background:#1f2a60; color:var(--text); border:1px solid #3a4aa3; border-radius:8px; padding:6px; font:inherit }
    .status { font-size:14px; color:var(--muted) }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #4150a8;
            color:#cbd5ff; background:#0c1536; margin-right:6px }
    .grid2 { display:grid; grid-template-columns:1fr 1fr; gap:16px }
    pre { white-space:pre-wrap; margin:0 }
    .footer { opacity:.7; margin-top:24px; font-size:13px; text-align:center }
    .ok { color:var(--good) } .fail { color:var(--bad) }
  </style>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
</head>

<body>
  <div class="wrap">
    <div class="hero">
      <div>
        <h1>Spec-Driven Firmware Verifier</h1>
        <div class="sub">Paste Arduino-style C code + choose a rule pack → get violations & auto-fixes. 100% in-browser via Pyodide.</div>
      </div>
      <div class="card" style="min-width:260px">
        <div class="status" id="status">⏳ Loading Python runtime…</div>
        <div style="font-size:12px;color:#b8c1ff">No server · No tracking · Works offline after load</div>
      </div>
    </div>

    <div class="row" style="margin-top:16px">
      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <div class="pill">Firmware C code</div>
          <div class="controls">
            <select id="sampleSelect">
              <option value="bad_gpio">Sample: GPIO used before init (bad)</option>
              <option value="good_gpio">Sample: GPIO correct (good)</option>
              <option value="uart_bad">Sample: UART missing begin (bad)</option>
              <option value="pwm_bad">Sample: PWM missing OUTPUT (bad)</option>
            </select>
            <button id="loadSample">Load</button>
          </div>
        </div>
        <textarea id="code"></textarea>
      </div>

      <div class="card">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <div class="pill">Hardware Spec (JSON)</div>
          <div class="controls">
            <select id="rulePackSelect">
              <option value="default">Rule Pack: Default</option>
              <option value="strict_gpio">Rule Pack: Strict GPIO</option>
              <option value="uart_only">Rule Pack: UART Only</option>
              <option value="pwm_uart">Rule Pack: PWM + UART</option>
            </select>
            <button id="loadRulePack">Load</button>
          </div>
        </div>
        <textarea id="spec"></textarea>
      </div>
    </div>

    <div class="controls" style="margin-top:16px">
      <button class="primary" id="verifyBtn">Verify</button>
      <button class="good" id="autofixBtn">Auto-Fix → Apply</button>
      <button id="exportBtn">Export JSON</button>
    </div>

    <div class="grid2" style="margin-top:16px">
      <div class="card"><div class="pill">Findings</div><pre id="findings">(run the verifier)</pre></div>
      <div class="card"><div class="pill">Auto-Fixed Code (preview)</div><pre id="fixed">(no fixes yet)</pre></div>
    </div>

    <div class="footer">Built with Pyodide. Firmware verification made easy ✅</div>
  </div>

<script>
const samples = {
  bad_gpio: `// Using pin 5 before init
void setup(){
  digitalWrite(5, HIGH); // should require pinMode(5, OUTPUT) first
}
void loop(){}`,
  good_gpio: `void setup(){
  pinMode(5, OUTPUT);
  digitalWrite(5, HIGH);
}
void loop(){}`,
  uart_bad: `void setup(){
  Serial.print("hello"); // missing Serial.begin
}
void loop(){}`,
  pwm_bad: `void setup(){
  analogWrite(9, 300); // no pinMode(9, OUTPUT)
}
void loop(){}`
};

const rulePacks = {
  default: {
    pins: { "5":{"mode":"OUTPUT","must_init":true}, "9":{"mode":"OUTPUT","must_init":true}, "13":{"mode":"OUTPUT","must_init":true} },
    uart: { must_begin:true, allowed_baud:[9600,115200] },
    pwm: { range:[0,255], require_output_mode:true }
  },
  strict_gpio: {
    pins: { "2":{"mode":"INPUT","must_init":true}, "5":{"mode":"OUTPUT","must_init":true}, "9":{"mode":"OUTPUT","must_init":true}, "13":{"mode":"OUTPUT","must_init":true} },
    uart: { must_begin:false }, pwm: { range:[0,255], require_output_mode:true }
  },
  uart_only: { pins:{}, uart:{ must_begin:true, allowed_baud:[9600] }, pwm:{} },
  pwm_uart: {
    pins: { "3":{"mode":"OUTPUT","must_init":true}, "9":{"mode":"OUTPUT","must_init":true} },
    uart: { must_begin:true, allowed_baud:[9600,57600,115200] },
    pwm: { range:[0,200], require_output_mode:true }
  }
};

const codeEl=document.getElementById('code');
const specEl=document.getElementById('spec');
const findingsEl=document.getElementById('findings');
const fixedEl=document.getElementById('fixed');
const statusEl=document.getElementById('status');

document.getElementById('loadSample').onclick=()=>{ 
  codeEl.value=samples[document.getElementById('sampleSelect').value]; 
  findingsEl.textContent="(run the verifier)";
  fixedEl.textContent="(no fixes yet)";
};
document.getElementById('loadRulePack').onclick=()=>{ 
  specEl.value=JSON.stringify(rulePacks[document.getElementById('rulePackSelect').value],null,2); 
  findingsEl.textContent="(run the verifier)";
  fixedEl.textContent="(no fixes yet)";
};

codeEl.value=samples.bad_gpio;
specEl.value=JSON.stringify(rulePacks.default,null,2);

let pyodideReady=(async()=>{
  statusEl.textContent="⏳ Loading Pyodide…";
  try {
    const py=await loadPyodide({indexURL:"https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"});
    statusEl.textContent="✅ Ready.";
    await py.runPythonAsync(`
import json, re

def safe_result(ok, **kwargs): 
    d={"ok":ok}
    d.update(kwargs)
    return d

def parse_spec(s):
    try: 
        return safe_result(True, spec=json.loads(s))
    except Exception as e: 
        return safe_result(False, error=f"Invalid JSON: {e}")

def analyze(code, spec):
    violations = []
    pin_inited = set()
    uart_began = False
    
    # Fixed regex patterns with proper escaping
    r_pinmode = re.compile(r"pinMode\\s*\\(\\s*(\\d+)\\s*,\\s*(\\w+)\\s*\\)")
    r_dwrite = re.compile(r"digitalWrite\\s*\\(\\s*(\\d+)\\s*,")
    r_awrite = re.compile(r"analogWrite\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)")
    r_sbegin = re.compile(r"Serial\\.begin\\s*\\(\\s*(\\d+)\\s*\\)")
    r_sio = re.compile(r"Serial\\.(print|println|write)\\b")
    
    lines = code.splitlines()
    for idx, line in enumerate(lines, 1):
        # Check pinMode
        m = r_pinmode.search(line)
        if m:
            pin_inited.add(m.group(1))
        
        # Check Serial.begin
        if r_sbegin.search(line):
            uart_began = True
        
        # Check digitalWrite
        m = r_dwrite.search(line)
        if m:
            p = m.group(1)
            pin_spec = spec.get("pins", {}).get(p, {})
            if pin_spec.get("must_init") and p not in pin_inited:
                violations.append({
                    "kind": "gpio_init",
                    "message": f"digitalWrite({p}) before pinMode({p}, OUTPUT)",
                    "line": idx
                })
        
        # Check analogWrite
        m = r_awrite.search(line)
        if m:
            p, val_str = m.groups()
            val = int(val_str)
            pwm_spec = spec.get("pwm", {})
            
            # Check range
            rng = pwm_spec.get("range")
            if rng and not (rng[0] <= val <= rng[1]):
                violations.append({
                    "kind": "pwm_range",
                    "message": f"analogWrite({p},{val}) outside range {rng}",
                    "line": idx
                })
            
            # Check pinMode requirement
            if pwm_spec.get("require_output_mode") and p not in pin_inited:
                violations.append({
                    "kind": "pwm_mode",
                    "message": f"analogWrite({p},{val}) requires pinMode({p}, OUTPUT)",
                    "line": idx
                })
        
        # Check Serial I/O
        if r_sio.search(line) and spec.get("uart", {}).get("must_begin") and not uart_began:
            violations.append({
                "kind": "uart_begin",
                "message": "Serial I/O before Serial.begin()",
                "line": idx
            })
    
    return safe_result(True, violations=violations)

def auto_fix(code, spec, analysis):
    lines = code.splitlines()
    inserts = []
    
    # Add Serial.begin if needed
    if any(v["kind"] == "uart_begin" for v in analysis["violations"]):
        baud = spec.get("uart", {}).get("allowed_baud", [9600])[0]
        inserts.append(f"  Serial.begin({baud});")
    
    # Add missing pinMode declarations
    missing_pins = set()
    for v in analysis["violations"]:
        if v["kind"] in ("gpio_init", "pwm_mode"):
            # Extract pin number from message
            m = re.search(r"\\((\\d+)[,)]", v["message"])
            if m:
                missing_pins.add(m.group(1))
    
    for p in sorted(missing_pins, key=int):
        inserts.append(f"  pinMode({p}, OUTPUT);")
    
    if not inserts:
        return code
    
    # Find setup function and insert fixes
    for i, line in enumerate(lines):
        if re.match(r"void\\s+setup\\s*\\([^)]*\\)\\s*\\{", line.strip()):
            return "\\n".join(lines[:i+1] + inserts + lines[i+1:])
    
    return code

def verify_entry(code, spec_str):
    try:
        parsed = parse_spec(spec_str)
        if not parsed["ok"]:
            return safe_result(False, error=parsed["error"])
        
        spec = parsed["spec"]
        analysis = analyze(code, spec)
        
        if not analysis["ok"]:
            return safe_result(False, error="Analysis failed")
        
        fixed = auto_fix(code, spec, analysis)
        
        return safe_result(True, analysis=analysis, fixed=fixed)
    
    except Exception as e:
        return safe_result(False, error=f"Exception: {str(e)}")
    `);
    return py;
  } catch(e) {
    statusEl.textContent="❌ Failed to load";
    throw e;
  }
})();

async function runVerify(applyFix=false){
  try {
    const py = await pyodideReady;
    
    py.globals.set("JS_CODE", codeEl.value);
    py.globals.set("JS_SPEC", specEl.value);

    // Execute verification
    const resultRaw = await py.runPythonAsync(`verify_entry(JS_CODE, JS_SPEC)`);
    const result = resultRaw.toJs({ dict_converter: Object });
    resultRaw.destroy();

    if (!result || typeof result !== "object") {
      findingsEl.textContent = "❌ Invalid result from Python";
      fixedEl.textContent = "(no fixes)";
      return;
    }

    if (!result.ok) {
      findingsEl.textContent = "❌ " + (result.error || "Unknown error");
      fixedEl.textContent = "(no fixes)";
      return;
    }

    const violations = (result.analysis && result.analysis.violations) ? result.analysis.violations : [];
    
    if (violations.length === 0) {
      findingsEl.textContent = "✅ No violations found";
      fixedEl.textContent = "(no fixes needed)";
    } else {
      findingsEl.textContent = violations.map((v, i) => 
        `#${i+1} ❌ [${v.kind}] line ${v.line || "-"}: ${v.message}`
      ).join("\\n");
      
      fixedEl.textContent = result.fixed || "(no fixes generated)";
      
      if (applyFix && result.fixed) {
        codeEl.value = result.fixed;
      }
    }

    window.__lastReport = result;
    
  } catch(e) {
    findingsEl.textContent = "❌ Runtime error: " + e.message;
    fixedEl.textContent = "(no fixes)";
  }
}

document.getElementById("verifyBtn").onclick = () => runVerify(false);
document.getElementById("autofixBtn").onclick = () => runVerify(true);
document.getElementById("exportBtn").onclick = () => {
  const report = window.__lastReport || { error: "No analysis performed" };
  const blob = new Blob([JSON.stringify(report, null, 2)], {type: "application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "verifier_report.json";
  a.click();
  URL.revokeObjectURL(a.href);
};
</script>
</body>
</html>
